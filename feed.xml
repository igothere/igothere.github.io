<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://igothere.github.io/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="http://igothere.github.io/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2023-03-13T01:12:23+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/feed.xml</id><title type="html">Elegantly Brilliantly</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Eden</name></author><entry><title type="html">국내 SBOM 속성 규격</title><link href="http://igothere.github.io/jekyll-theme-yat/sbom/2023/02/09/tenth.html" rel="alternate" type="text/html" title="국내 SBOM 속성 규격" /><published>2023-02-09T00:00:00+00:00</published><updated>2023-02-09T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/sbom/2023/02/09/tenth</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/sbom/2023/02/09/tenth.html"><![CDATA[<h1 id="국내-sbom-속성-규격">국내 SBOM 속성 규격</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: center">번호</th>
      <th style="text-align: center">구분</th>
      <th style="text-align: center">속성</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">공급자 (Supplier Name)</td>
      <td style="text-align: center">ComponentSupplier:</td>
      <td style="text-align: center">소프트웨어를 통한 위험관리와 책임을 위해 공급자 이름에 대한 확인이 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">저작권자 (Author Name)</td>
      <td style="text-align: center">Component Author:</td>
      <td style="text-align: center">소프트웨어의 라이선스에 따른 사용권한 , 기술적 협의 등을 위해 해당 소프트웨어의 원저작권자에 대한 확인이 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">컴포넌트 (Component Name)</td>
      <td style="text-align: center">ComponentName:</td>
      <td style="text-align: center">공개 소프트웨어 커뮤니티에는 많은 개발자들이 참여하고 있고 코드가 공개된 만큼보안취약점에 대한 발견과 문제점 해결을 통한 보안 패치 등의 해결책이 빠르게제공되고 있다 . 또한 공개 소프트웨어에는 다양한 라이선스가 적용되어 있어 사용결합형태와 조건에 따라 라이선스 위반이 발생되지 않도록 관리하여야 한다 . 이러한보안취약점과 라이선스를 관리하기 위해서는 사용된 정확한 컴포넌트 이름을 식별하여야한다 . 동일한 소스코드에도 다양한 컴포넌트가 교집합으로 적용될 수도 있고 잘못된컴포넌트 이름이 적용되어 있을 수도 있기 때문에 명확한 컴포넌트 이름을 식별하기위해서는 전문적인 스캐닝 도구를 통한 확인이 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">버전 (Version String)</td>
      <td style="text-align: center">ComponentVersion:</td>
      <td style="text-align: center">공개 소프트웨어 커뮤니티에는 많은 개발자들이 참여하고 있고 코드가 공개된 만큼보안취약점에 대한 발견과 문제점 해결이 빠르지만 커뮤니티 참여 개발자가 많지않거나 , 기술 지원 전문 업체가 존재하지 않는 컴포넌트인 경우에는 관리 소홀로 인해보안성이 더 취약할 수밖에 없다 . 따라서 , 소프트웨어 개발에 사용된 명확한 컴포넌트이름과 함께 버전에 대한 확인이 필요하다 . 버전 확인 및 관리에 있어서는 다음과 같은경우에 대한 검토가 필요하다 . 보안 패치가 빨리 이루어졌다 하더라도 이용자 측에서체계적인 컴포넌트 식별과 버전 관리가 이루어지지 않는 경우 , 버전 변경에 따른 호환성문제 등을 우려하여 이용자가 패치를 적용하지 않는 경우 , 소프트웨어 개발 시 공개소프트웨어 사용 여부가 확인되지 않는 경우 , 소스코드 확보가 어려운 외주 개발 모듈등으로 인해 공개 소프트웨어가 사용 되었는지 여부조차 확인하기 어려운 경우이다.이러한 경우에는 버전확인을 통한 보안 패치가 적용되기 어렵기 때문에 이를 고려한공개 소프트웨어 관리 및 외주개발 모듈에 대한 별도 관리가 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">고유식별자(Unique Identifier)</td>
      <td style="text-align: center">FormatID:</td>
      <td style="text-align: center">소프트웨어 컴포넌트 단위별 SBOM 에서 사용하는 고유 식별자를 할당하여 관리하여야한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">컴포넌트 해시 (Component Hash)</td>
      <td style="text-align: center">FileChecksum:</td>
      <td style="text-align: center">해당 소프트웨어를 구성하고 있는 개별 파일들에 대한 고유한 정보 확인을 통해 신뢰성을 확보하여야 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">라이선스 명 (License Name)</td>
      <td style="text-align: center">Component License:</td>
      <td style="text-align: center">공개 소프트웨어에 적용된 라이선스 위반으로 인한 제반 위험 요소를 예방하기 위해서는공개 소프트웨어에 대한 라이선스를 명확히 확인하여야 한다 . 라이선스 확인을 통해 소프트웨어의 사용 목적에 부합된 공개 소프트웨어 사용 여부 검토는 물론 , 사용된 공개소프트웨어 간의 라이선스 호환성에 대한 검토 또한 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">라이선스 결합형태(License Usage)</td>
      <td style="text-align: center">Dynamic/Satic Linking:</td>
      <td style="text-align: center">공개 소프트웨어 컴포넌트의 사용 결합형태는 공개 소프트웨어에 적용된 라이선스 적용범위에 있어 매우 중요하다 . 따라서 , 해당 컴포넌트를 수정하여 사용하는지 , 수정하지 않고 파일단위로 복제하여 사용하는지 , 라이브러리를 동적 혹은 정적 링킹을 통해 사용하는지 등에 대한 명확한 결합형태에 대한 확인이 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">보안취약점 DB(Vulnerability DB)</td>
      <td style="text-align: center">VulnerabilityDB : NVD</td>
      <td style="text-align: center">최근 공개 소프트웨어에서 심각한 취약점이 발견되고 있으며 이로 인한 해킹사고 또한계속해서 발생하고 있다 . 2021 년 아파치 소프트웨어 재단의 Java 프로그래밍 언어로제작된 Log4j 라이브러리를 사용하는 대부분의 인터넷 서비스에서 매우 중대한 보안취약점이 발견된 사건이 있었다 . 테나블 (Tenable) 에서는 이 사태를 ‘ 하트블리드와 CPU게이트 따위는 비교도 안 될 만큼 , 컴퓨터 인터넷 역사를 통틀어 사상 최악의 보안결함일 수도 있다 ‘ 고 경고했다 . 또한 , 2022 년 4 월 해커들이 최근 발견된 스프링프레임워크 내 원격코드실행 (RCE) 취약점인 ‘ 스프링 4 셸 ‘ 을 악용해 , 봇넷 악성코드를배포하고 감염시킨 것으로 확인됐다 . 글로벌 사이버보안업체 트렌드마이크로는8 일 ( 현지시간 ) 이 같은 내용의 스프링 4 셸 (CVE-2022-22965) 취약점 악용 분석 보고서를공개했다 . 스프링은 자바 기반 애플리케이션 개발을 빠르고 효율적으로 진행할 수 있게지원하는 오픈소스 프레임워크다 . 이처럼 공개 소프트웨어에서 많은 취약점이 존재하는가장 큰 이유는 소스코드가 공개되어 있다는 점이다 . 소스코드가 공개된 만큼 공격자입장에서도 공격 대상 선정 및 악의적인 역분석이 매우 용이 할 수 있다 . 따라서 , 미국의NIST(National Institute of Standards and Technology/ U.S. Department ofCommerce) 에서는 이러한 공개 소프트웨어의 보안취약점에 대한 관리를 위해NVD(National Vulnerability Database) 를 통해 신규 보안취약점 및 취약 심각도를평가하여 공개하고 있다 . SBOM 관리의 핵심 목적은 보안취약점에 대한 예방이기 때문에해당 보안취약점에 대한 출처 확인은 매우 중요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">관계성 (Relationship)</td>
      <td style="text-align: center">IncludeComponent, ImportComponent</td>
      <td style="text-align: center">소프트웨어 컴포넌트 간의 종속성 및 의존성을 확인하여 라이브러리와 같은 보안취약점패치 여부 및 라이선스 적용 범위를 확인하여야 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">릴리즈 날짜(Release Date)</td>
      <td style="text-align: center">ReleaseDate:</td>
      <td style="text-align: center">소프트웨어 컴포넌트의 라이선스 출처와 보안취약점 버전의 상호 확인을 위해 해당 컴포넌트의 릴리즈 날짜에 대한 확인이 필요하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">12</td>
      <td style="text-align: center">CVE ID</td>
      <td style="text-align: center">CVE-Year-Serial Number</td>
      <td style="text-align: center">CVE ID 는 공개적으로 알려진 보안 결함 목록으로서 다른 버그로부터 독립적으로 수정할수 있는 결함이다 . 시간대 별로 발생된 보안취약점 또는 위험 노출을 정리한 목록을 제공한다 . 소프트웨어의 보안취약점에 활용되는 위험관리 프레임워크는 소프트웨어의 보안약점의 중요도를 평가하는 평가체계로 CWE 프로젝트의 일부로 수행되고 있는 CWSS(Common Weakness Scoring System), 산학협동 연구소인 SANS(SysAdmin, Audit,Network, Security) 에서 관리하는 CWE 에 리스팅된 소프트웨어 취약점 중 가장 위험한25 개의 취약점에 점수를 매긴 리스트를 제공하는 SANS Top 25, 시간대 별로 발생된 보안취약점 또는 위험 노출을 정리한 목록인 CVE (Common Vulnerabilities andExposures), 평가된 취약점의 우선순위를 부여하여 관리하기 위해 IT 취약점에 대한 영향과 특성을 표현하기 위한 공통 프레임워크를 제공하는 CVSS (Common VulnerabilitiesScoring System) 와 보안 콘텐츠 자동화 프로토콜 (SCAP) 를 사용하여 표현된 미국 정부의표준 기반 취약점 관리 데이터 저장소인 NVD 가 활용되고 있다 . 본 표준에서는 다양한위험관리 프레임워크 중에서 가장 직관적이면서도 일반적으로 활용되고 있는 CVE ID 와CVSS Base Score, CVSS Severity 를 위험관리 구성요소로 제시한다 .</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">CVSS Base Score</td>
      <td style="text-align: center">Base :, Impact :,Exploitability :</td>
      <td style="text-align: center">소프트웨어 컴포넌트의 보안취약점에 대한 기본 위험성 , 영향성 , 악용 가능성에 대한 0 –10 점 범위의 점수로서 취약점에 대한 지표를 제공한다 .</td>
    </tr>
    <tr>
      <td style="text-align: center">14</td>
      <td style="text-align: center">CVSS Severity</td>
      <td style="text-align: center">CVSS Severity: High, Medium, Low, None</td>
      <td style="text-align: center">소프트웨어 컴포넌트의 보안취약점에 대한 심각성 지표로서 심각도에 따라 High,Medium, Low, None 으로 구분하여 심각성에 대한 정도를 제공한다 .</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Eden</name></author><category term="sbom" /><category term="sbom" /><category term="spdx" /><summary type="html"><![CDATA[국내 SBOM 속성 규격]]></summary></entry><entry><title type="html">SPDX 규격</title><link href="http://igothere.github.io/jekyll-theme-yat/sbom/2023/02/07/ninth.html" rel="alternate" type="text/html" title="SPDX 규격" /><published>2023-02-07T00:00:00+00:00</published><updated>2023-02-07T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/sbom/2023/02/07/ninth</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/sbom/2023/02/07/ninth.html"><![CDATA[<h1 id="spdx">SPDX</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: center">번호</th>
      <th style="text-align: left">메타데이터명</th>
      <th>값</th>
      <th>필수여부</th>
      <th>예제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">SPDXVersion</td>
      <td>SPDX-2.3</td>
      <td>O</td>
      <td>SPDXVersion: SPDX-2.3</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left">DataLicense</td>
      <td>CC0-1.0</td>
      <td>O</td>
      <td>DataLicense: CC0-1.0</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left">SPDXID</td>
      <td>SPDXRef-DOCUMENT</td>
      <td> </td>
      <td>SPDXID: SPDXRef-DOCUMENT</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left">DocumentName</td>
      <td>glibc-v2.3</td>
      <td>O</td>
      <td>DocumentName: glibc-v2.3, DocumentName: ubuntu-14.04</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">DocumentNamespace</td>
      <td>https://spdx.org/spdxdocs/spdx-tools-v1.2-3F2504E0-4F89-41D3-9A0C-0305E82…</td>
      <td>O</td>
      <td>DocumentNamespace: https://spdx.org/spdxdocs/spdx-tools-v1.2-3F2504E0-4F89-41D3-9A0C-0305E82…</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: left">ExternalDocumentRef</td>
      <td>DocumentRef-spdx-tool-1.2 https://spdx.org/spdxdocs/spdx-tools-v1.2-3F2504E0-4F89-41D3-9A0C-0305E82C3301 SHA1: d6a770ba38583ed4bb4525bd96e50461655d2759</td>
      <td>X</td>
      <td>ExternalDocumentRef:DocumentRef-spdx-tool-1.2 https://spdx.org/spdxdocs/spdx-tools-v1.2-3F2504E0-4F89-41D3-9A0C-0305E82C3301 SHA1: d6a770ba38583ed4bb4525bd96e50461655d2759</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: left">LicenseListVersion</td>
      <td>3.17</td>
      <td>X</td>
      <td>LicenseListVersion: 3.17</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: left">Creator</td>
      <td> </td>
      <td>O</td>
      <td>Creator: Person: Jane Doe () Creator: Organization: ExampleCodeInspect () Creator: Tool: LicenseFind-1.0</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: left">Created</td>
      <td>2010-01-29T18:30:22Z</td>
      <td>O</td>
      <td>Created: 2010-01-29T18:30:22Z</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: left">CreatorComment</td>
      <td>&lt;**text**&gt;This SPDX document was created **by** a combination **of** **using** a free tool, **as** indicated above, and manual analysis **by** several authors **of** the code.&lt;/**text**&gt;</td>
      <td>X</td>
      <td>CreatorComment: &lt;**text**&gt;This SPDX document was created **by** a combination **of** **using** a free tool, **as** indicated above, and manual analysis **by** several authors **of** the code.&lt;/**text**&gt;</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: left">DocumentComment</td>
      <td>&lt;**text**&gt;This document was created **using** SPDX 2.3, version 3.17 **of** the SPDX License List and refering **to** licenses **in** file MyCompany.Approved.Licenses.spdx.&lt;/**text**&gt;</td>
      <td>X</td>
      <td>DocumentComment: &lt;**text**&gt;This document was created **using** SPDX 2.3, version 3.17 **of** the SPDX License List and refering **to** licenses **in** file MyCompany.Approved.Licenses.spdx.&lt;/**text**&gt;</td>
    </tr>
  </tbody>
</table>

<p>참고사이트: https://spdx.github.io/spdx-spec/v2.3/document-creation-information/</p>]]></content><author><name>Eden</name></author><category term="sbom" /><category term="sbom" /><category term="spdx" /><summary type="html"><![CDATA[SPDX]]></summary></entry><entry><title type="html">Web Was에 대하여</title><link href="http://igothere.github.io/jekyll-theme-yat/web/2022/06/22/eighth.html" rel="alternate" type="text/html" title="Web Was에 대하여" /><published>2022-06-22T00:00:00+00:00</published><updated>2022-06-22T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/web/2022/06/22/eighth</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/web/2022/06/22/eighth.html"><![CDATA[<h1 id="web--was">WEB &amp; WAS</h1>

<h2 id="web-server">Web server</h2>

<ol>
  <li>클라이언트(웹 브라우저)에게 요청을 받는다.</li>
  <li>요청이 정적인 콘텐츠 인지 동적인 콘텐츠 인지 판단하다.</li>
  <li>정적인 콘텐츠인 경우 web server가 바로 응답해준다.</li>
  <li>동적인 콘텐츠인 경우 was에 요청을 전달하고 was에서 받은 결과를 응답해준다.</li>
</ol>

<ul>
  <li>정적인 콘텐츠는 html, css, js, image 등 어느 사용자에게나 동일한 결과값을 보여주는 것이고
동적인 콘텐츠는 데이터베이스 등에서 데이터를 가져오거나 로직처리를 하여 사용자 마다 다른 결과값을 보여주는 것이다.</li>
</ul>

<h2 id="web-server의-종류">Web server의 종류</h2>

<p>Apache, Nginx, Iis 등이 대표적이다.</p>

<h2 id="wasweb-application-server">Was(Web Application Server)</h2>

<ol>
  <li>Was는 Web server + Web Container로 구성되어 있다.</li>
  <li>Web server의 요청을 Web Container가 받아서 처리하고 Web server에 응답해준다.</li>
  <li>현재는 was에 있는 Web server도 정적인 콘텐츠를 처리하는데 성능상 큰 차이는 없다.</li>
</ol>

<h2 id="was의-종류">Was의 종류</h2>

<p>Apache Tomcat, Jboss, Jeus 등이 대표적이다.</p>

<h2 id="web-service-architecture">Web Service Architecture</h2>

<p>Client -&gt; Web Server -&gt; WAS -&gt; DB의 구조라면 아래 이미지와 같은 아키텍처로 처리된다.</p>

<p><img src="/assets/images/web-service-architecture.png" alt="image" /></p>]]></content><author><name>Eden</name></author><category term="web" /><category term="apache" /><category term="tomcat" /><category term="web" /><category term="was" /><summary type="html"><![CDATA[WEB &amp; WAS]]></summary></entry><entry><title type="html">우분투 apache2 + tomcat 간단연동</title><link href="http://igothere.github.io/jekyll-theme-yat/apache/2022/04/08/seventh.html" rel="alternate" type="text/html" title="우분투 apache2 + tomcat 간단연동" /><published>2022-04-08T00:00:00+00:00</published><updated>2022-04-08T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/apache/2022/04/08/seventh</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/apache/2022/04/08/seventh.html"><![CDATA[<h1 id="우분투-apache2--tomcat-간단연동">우분투 apache2 + tomcat 간단연동</h1>

<h2 id="사양">사양</h2>
<ol>
  <li>ubuntu 20.04</li>
  <li>apache2 2.4.41</li>
  <li>tomcat 9.0.62</li>
</ol>

<h2 id="apache설치">apache설치</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>suto apt-get update

sudo apt-get install apache2

sudo apt-get install libapache2-mod-jk  //modjk를 이용하여 연동

cd /etc/apache2       // 설정파일 위치

</code></pre></div></div>
<h2 id="tomcat-설치">tomcat 설치</h2>

<ol>
  <li>https://tomcat.apache.org/download-90.cgi //톰캣 공식 홈페이지에서 다운로드 받는다</li>
  <li>본인이 원하는 위치에 압축을 해제 한다.</li>
</ol>

<h2 id="apache2-설정">apache2 설정</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo a2enmod jk //modjk 활성화

cd /etc/apache2

sudo vi workers.properties

// workers.properties에 입력
worker.list = tomcat

worker.tomcat.port = 8009  //modjk 사용포트
worker.tomcat.host = localhost
worker.tomcat.type = ajp13

//jk.conf 설정
sudo vi /etc/apache2/mods-available/jk.conf

JkWorkersFile /etc/libapache2-mod-jk/workers.properties // 이부분을 처음에 생성한 worker.properties 경로로 변경

JkWorkersFile /etc/apache2/workers.properties  

//000-default.conf 설정
sudo vi /etc/apache2/sites-available/000-default.conf

&lt;VirtualHost *:80&gt;
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request's Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        #ServerName localhost
        ServerAdmin webmaster@localhost
        
        #DocumentRoot /var/www/html
        DocumentRoot /root/ROOT  //소스 경로

        JkMount /* tomcat

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the
        # following line enables the CGI configuration for this host only
        # after it has been globally disabled with "a2disconf".
        #Include conf-available/serve-cgi-bin.conf

&lt;/VirtualHost&gt;

여기까지 하면 apache 설정은 끝이다.

</code></pre></div></div>

<h2 id="tomcat-설정">tomcat 설정</h2>

<p>tomcat 설정은 간단하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//tomcat 디렉토리에서 conf/server.xml 연다
&lt;Service name="Catalina"&gt;
~~~~
&lt;Connector protocol="AJP/1.3" address="0.0.0.0" port="8009" connectionTimeout="20000" redirectPort="8443" secretRequired="false"/&gt;
~~~~
&lt;/Service&gt;
// 저 서비스 안에 Connector 한줄만 추가해주면 된다.
</code></pre></div></div>

<h2 id="테스트">테스트</h2>

<ol>
  <li>tomcat 과 apache 모두 기동을 시켜준다</li>
  <li>tomcat만 단독사용시 tomcat 기본 포트인 8080을 url 뒤에 넣어줘야 하지만 이제 apache와 연동이 되어있기때문에 그냥 url만 입력하여도 tomcat의 기본화면으로 넘어가진다.</li>
</ol>

<h2 id="비고">비고</h2>
<p>만약 apache 하나에 톰캣을 개 연결하고 싶다면 worker.properties에 이런식으로 추가해주면 된다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker.list = tomcat1,tomcat2

worker.tomcat1.port = 8009  //modjk 사용포트
worker.tomcat1.host = localhost
worker.tomcat1.type = ajp13

worker.tomcat2.port = 8009  //동일서버에 2대를 올리는 거라면 포트가 중복되면 안되니 1번과 2번의 포트는 다르게 해준다 ex) 8009 -&gt; 8019 tomcat의 server.xml도 변경해줘야 한다.
worker.tomcat2.host = localhost
worker.tomcat2.type = ajp13
</code></pre></div></div>

<p>000-default.conf는 virtualhost를 하나더 추가해주자</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;VirtualHost *:80&gt;
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request's Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        #ServerName localhost
        ServerAdmin webmaster@localhost
        
        #DocumentRoot /var/www/html
        DocumentRoot /root/ROOT1  //소스 경로

        JkMount /* tomcat1

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the
        # following line enables the CGI configuration for this host only
        # after it has been globally disabled with "a2disconf".
        #Include conf-available/serve-cgi-bin.conf

&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
        # The ServerName directive sets the request scheme, hostname and port that
        # the server uses to identify itself. This is used when creating
        # redirection URLs. In the context of virtual hosts, the ServerName
        # specifies what hostname must appear in the request's Host: header to
        # match this virtual host. For the default virtual host (this file) this
        # value is not decisive as it is used as a last resort host regardless.
        # However, you must set it for any further virtual host explicitly.
        #ServerName localhost
        ServerAdmin webmaster@localhost
        
        #DocumentRoot /var/www/html
        DocumentRoot /root/ROOT2 //소스 경로

        JkMount /* tomcat2

        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
        # error, crit, alert, emerg.
        # It is also possible to configure the loglevel for particular
        # modules, e.g.
        #LogLevel info ssl:warn

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        # For most configuration files from conf-available/, which are
        # enabled or disabled at a global level, it is possible to
        # include a line for only one particular virtual host. For example the
        # following line enables the CGI configuration for this host only
        # after it has been globally disabled with "a2disconf".
        #Include conf-available/serve-cgi-bin.conf

&lt;/VirtualHost&gt;
</code></pre></div></div>]]></content><author><name>Eden</name></author><category term="apache" /><category term="apache" /><category term="tomcat" /><category term="mod_jk" /><summary type="html"><![CDATA[우분투 apache2 + tomcat 간단연동]]></summary></entry><entry><title type="html">postgresql db 이중화 2</title><link href="http://igothere.github.io/jekyll-theme-yat/postgresql/2022/03/29/sixth.html" rel="alternate" type="text/html" title="postgresql db 이중화 2" /><published>2022-03-29T00:00:00+00:00</published><updated>2022-03-29T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/postgresql/2022/03/29/sixth</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/postgresql/2022/03/29/sixth.html"><![CDATA[<h1 id="postgresql-db-이중화-2">postgresql db 이중화 2</h1>

<h2 id="-이번엔-pgpool을-통해서-자동-failover-하는-부분을-설명한다-이-페이지-에서는-설정-할-부분이-꽤-많다">* 이번엔 pgpool을 통해서 자동 failover 하는 부분을 설명한다. 이 페이지 에서는 설정 할 부분이 꽤 많다</h2>

<h2 id="1-pgpool-버전">1. pgpool 버전</h2>
<ul>
  <li>pgpool 4.3.1</li>
  <li>primary,standby 모든 서버에 설치가 필요하다.</li>
</ul>

<h2 id="2-설치">2. 설치</h2>
<ul>
  <li>https://www.pgpool.net/mediawiki/index.php/Apt_Repository</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" &gt; /etc/apt/sources.list.d/pgdg.list'

wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -

//상위 부분은 아마 postgresql을 설치 했다면 이미 등록했으므로 다시 할 필요가 없다.

sudo apt-get update

sudo apt-get -y install pgpool2 libpgpool2 postgresql-14-pgpool2
</code></pre></div></div>

<h2 id="3-설정">3. 설정</h2>
<ul>
  <li>이 설정은 pgpool 공식 문서를 보고 작성 하였다. (https://www.pgpool.net/docs/latest/en/html/example-cluster.html#EXAMPLE-CLUSTER-STRUCTURE)</li>
  <li>postgresql replacation에 이어서 작성이기 떄문에 DB관련 설정은 이전글을 참고 하면 된다.</li>
  <li>우분투 20.04 기준이다.</li>
  <li>코드중 [all servers]는 전체 서버에 적용하고 [server1]은 primary 서버에만 적용하면 된다.</li>
</ul>

<h3 id="31-pgpool은-root와-postgres-계정이-각-서버-ssh-통신에서-암호-없이-사용-가능해야-하기-때문에-미리-ssh-키를-생성하고-각-서버에-등록해준다">3.1 pgpool은 root와 postgres 계정이 각 서버 ssh 통신에서 암호 없이 사용 가능해야 하기 때문에 미리 ssh 키를 생성하고 각 서버에 등록해준다.</h3>
<p>설정에 앞서 alias로 server1,server2,server3 으로 했는데 미리 /etc/hosts 파일에</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.0.111 server1
192.168.0.112 server2
192.168.0.113 server3 
</code></pre></div></div>
<p>이런식으로 등록해주고 아래 설정을 시작하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[all servers]# cd ~/.ssh
[all servers]# ssh-keygen -t rsa -f id_rsa_pgpool
[all servers]# ssh-copy-id -i id_rsa_pgpool.pub postgres@server1
[all servers]# ssh-copy-id -i id_rsa_pgpool.pub postgres@server2
[all servers]# ssh-copy-id -i id_rsa_pgpool.pub postgres@server3

[all servers]# su - postgres
[all servers]$ cd ~/.ssh
[all servers]$ ssh-keygen -t rsa -f id_rsa_pgpool
[all servers]$ ssh-copy-id -i id_rsa_pgpool.pub postgres@server1
[all servers]$ ssh-copy-id -i id_rsa_pgpool.pub postgres@server2
[all servers]$ ssh-copy-id -i id_rsa_pgpool.pub postgres@server3
</code></pre></div></div>

<h3 id="32-이전에-만들었던-repl-계정이-암호-없이-사용-할-수-있게-미리-파일에-등록을-한다">3.2 이전에 만들었던 repl 계정이 암호 없이 사용 할 수 있게 미리 파일에 등록을 한다.</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[all servers]# su - postgres
[all servers]$ vi /var/lib/pgsql/.pgpass
server1:5432:replication:repl:&lt;repl user password&gt;
server2:5432:replication:repl:&lt;repl user password&gt;
server3:5432:replication:repl:&lt;repl user password&gt;
server1:5432:postgres:postgres:&lt;postgres user password&gt;
server2:5432:postgres:postgres:&lt;postgres user password&gt;
server3:5432:postgres:postgres:&lt;postgres user password&gt;
[all servers]$ chmod 600  /var/lib/pgsql/.pgpass
</code></pre></div></div>

<p>그리고 방화벽 설정도 남아 있는데 일단 테스트 용이기 떄문에</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ufw disable
</code></pre></div></div>
<p>하고 작업하자. 추후 운영 할때는 상황에 맞게 적절하게 사용할 포트만 허용해주면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[all servers]# systemctl enable pgpool2.service
</code></pre></div></div>
<p>pgpool2 서비스를 시작시 자동으로 서비스 되게 등록</p>

<h3 id="33-pgpool_node_id-생성">3.3 pgpool_node_id 생성</h3>
<p>간단하다.
pgpool을 설치 했다면 /etc/pgpool2 디렉토리가 생성되어 있고 설정 파일들이 있을것이다.여기서 각 서버별로 pgpool_node_id 파일을 생성해주면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[server1]# cat /etc/pgpool2/pgpool_node_id
0
[server2]# cat /etc/pgpool2/pgpool_node_id
1
[server3]# cat /etc/pgpool2/pgpool_node_id
2
</code></pre></div></div>
<p>이렇게 나와주면 된다.</p>

<h3 id="34-pgpool-configuration">3.4 pgpool configuration</h3>
<ul>
  <li>이설정은 primary 서버에서만 설정을 진행 하고 추후에 standby 서버에 복사해주자.</li>
</ul>

<p>pgpool.conf 설정파일</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>backend_clustering_mode = 'streaming_replication'
listen_addresses = '*'
port = 9999
sr_check_user = 'pgpool'
sr_check_password = ''
health_check_period = 5
health_check_timeout = 30
health_check_user = 'pgpool'
health_check_password = ''
health_check_max_retries = 3
# - Backend Connection Settings -

backend_hostname0 = 'server1'
backend_port0 = 5432
backend_weight0 = 1
backend_data_directory0 = '/var/lib/postgresql/14/main' //postgresql이 설치 되는 경로
backend_flag0 = 'ALLOW_TO_FAILOVER'
backend_application_name0 = 'server1'

backend_hostname1 = 'server2'
backend_port1 = 5432
backend_weight1 = 1
backend_data_directory1 = '/var/lib/postgresql/14/main'
backend_flag1 = 'ALLOW_TO_FAILOVER'
backend_application_name1 = 'server2'

backend_hostname2 = 'server3'
backend_port2 = 5432
backend_weight2 = 1
backend_data_directory2 = '/var/lib/postgresql/14/main'
backend_flag2 = 'ALLOW_TO_FAILOVER'
backend_application_name2 = 'server3'

// 여기에 있는 shell 파일들은 모든 서버에 있어야 한다 미리 각 서버 해당 경로에 추가하자. 각 파일들은 하단에 작성해 두겠다.
failover_command = 'sudo sh /etc/pgpool2/failover.sh %d %h %p %D %m %H %M %P %r %R %N %S'
follow_primary_command = 'sudo sh /etc/pgpool2/follow_primary.sh %d %h %p %D %m %H %M %P %r %R'
wd_escalation_command = 'sudo sh /etc/pgpool2/escalation.sh'

recovery_user = 'postgres'
recovery_password = ''
recovery_1st_stage_command = 'recovery_1st_stage'

enable_pool_hba = on

use_watchdog = on

delegate_IP = '{VIP}'

if_up_cmd = '/usr/bin/sudo /sbin/ip addr add $_IP_$/24 dev enp0s8 label enp0s8:0'
if_down_cmd = '/usr/bin/sudo /sbin/ip addr del $_IP_$/24 dev enp0s8'
arping_cmd = '/usr/bin/sudo /usr/sbin/arping -U $_IP_$ -w 1 -I enp0s8'

if_cmd_path = '/sbin'
arping_path = '/usr/sbin'

hostname0 = 'server1'
wd_port0 = 9000
pgpool_port0 = 9999

hostname1 = 'server2'
wd_port1 = 9000
pgpool_port1 = 9999

hostname2 = 'server3'
wd_port2 = 9000
pgpool_port2 = 9999

wd_lifecheck_method = 'heartbeat'
wd_interval = 10

heartbeat_hostname0 = 'server1'
heartbeat_port0 = 9694
heartbeat_device0 = ''
heartbeat_hostname1 = 'server2'
heartbeat_port1 = 9694
heartbeat_device1 = ''
heartbeat_hostname2 = 'server3'
heartbeat_port2 = 9694
heartbeat_device2 = ''

wd_heartbeat_keepalive = 2
wd_heartbeat_deadtime = 30

log_destination = 'stderr'
logging_collector = on
log_directory = '/var/log/pgpool_log'
log_filename = 'pgpool-%Y-%m-%d_%H%M%S.log'
log_truncate_on_rotation = on
log_rotation_age = 1d
log_rotation_size = 10MB
</code></pre></div></div>
<p>pgpool.conf 설정은 여기까지 이고 설정 완료후</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[server1]# scp -p /etc/pgpool2/pgpool.conf root@server2:/etc/pgpool2/pgpool.conf
[server1]# scp -p /etc/pgpool2/pgpool.conf root@server3:/etc/pgpool2/pgpool.conf
</code></pre></div></div>
<p>standby 서버에도 복사해주자.</p>

<h3 id="35-기타-설정">3.5 기타 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[all servers]# echo 'pgpool:'`pg_md5 PCP password` &gt;&gt; /etc/pgpool2/pcp.conf

[all servers]# su - postgres
[all servers]$ echo 'localhost:9898:pgpool:&lt;pgpool user password&gt;' &gt; ~/.pcppass
[all servers]$ chmod 600 ~/.pcppass


[server1]# su - postgres
[server1]$ psql template1 -c "CREATE EXTENSION pgpool_recovery"

[all servers]# su - postgres
[all servers]$ echo 'some string' &gt; ~/.pgpoolkey
[all servers]$ chmod 600 ~/.pgpoolkey

[all servers]# su - postgres
[all servers]$ pg_enc -m -k ~/.pgpoolkey -u pgpool -p
db password: [pgpool user's password]
[all servers]$ pg_enc -m -k ~/.pgpoolkey -u postgres -p
db password: [postgres user's password]

# cat /etc/pgpool-II/pool_passwd
pgpool:AESheq2ZMZjynddMWk5sKP/Rw==
postgres:AESHs/pWL5rtXy2IwuzroHfqg==

[all servers]# mkdir /var/log/pgpool_log/
[all servers]# chown postgres:postgres /var/log/pgpool_log/
</code></pre></div></div>
<p>그리고 pool_hba.conf 파일도 아래와 같이 수정하자 postgresql의 pg_hba.conf와 유사하다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>host    all         pgpool           0.0.0.0/0          scram-sha-256
host    all         postgres         0.0.0.0/0          scram-sha-256

</code></pre></div></div>

<h3 id="36-서비스-설정">3.6 서비스 설정</h3>
<ul>
  <li>pgpool2는 시작할떄 pgpool_status 파일이 존재하면 pgpool_status 파일에서 백엔드 상태를 읽어오기 떄문에 시작 할때 pgpool_status 무시하고 실행하자</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[all servers]# sudo vi /lib/systemd/system/pgpool2.service

ExecStart=/usr/sbin/pgpool -D -n

</code></pre></div></div>

<h3 id="37-확인-및-테스트">3.7 확인 및 테스트</h3>
<ul>
  <li>설정이 완료 됐다면 primary 서버에서 잘 적용 됐는지 확인해 보자 아래와 같이 나오면 된다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[server1]# psql -h {VIP} -p 9999 -U pgpool postgres -c "show pool_nodes"

 node_id | hostname | port | status | pg_status | lb_weight |  role   | pg_role | select_cnt | load_balance_node | replication_delay | replication_state | replication_sync_state | last_status_change  
---------+----------+------+--------+-----------+-----------+---------+---------+------------+-------------------+-------------------+-------------------+------------------------+---------------------
 0       | server1  | 5432 | up     | up        | 0.333333  | primary | primary | 3          | false             | 0                 |                   |                        | 2022-03-28 16:22:14
 1       | server2  | 5432 | up     | up        | 0.333333  | standby | standby | 0          | false             | 0                 |                   |                        | 2022-03-28 16:22:14
 2       | server3  | 5432 | up     | up        | 0.333333  | standby | standby | 0          | true              | 0                 |                   |                        | 2022-03-28 16:22:14
</code></pre></div></div>

<ul>
  <li>Switching active/standby watchdog</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># pcp_watchdog_info -h {VIP} -p 9898 -U pgpool
Password:
3 3 YES server1:9999 Linux server1 server1

server1:9999 Linux server1 server1 9999 9000 4 LEADER 0 MEMBER #The Pgpool-II server started first became "LEADER".
server2:9999 Linux server2 server2 9999 9000 7 STANDBY 0 MEMBER #run as standby
server3:9999 Linux server3 server3 9999 9000 7 STANDBY 0 MEMBER #run as standby
</code></pre></div></div>
<p>여기서 primary서버의 pgpool 서비스를 내려보자</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[server1]# systemctl stop pgpool.service

# pcp_watchdog_info -p 9898 -h {VIP} -U pgpool
Password:
3 3 YES server2:9999 Linux server2 server2

server2:9999 Linux server2 server2 9999 9000 4 LEADER 0 MEMBER    #server2 is promoted to LEADER
server1:9999 Linux server1 server1 9999 9000 10 SHUTDOWN 0 MEMBER #server1 is stopped
server3:9999 Linux server3 server3 9999 9000 7 STANDBY 0 MEMBER   #server3 runs as STANDBY
</code></pre></div></div>
<p>server2 가 LEADER가 된걸 확인 할 수 있다.</p>

<ul>
  <li>failover Test</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[server1]# sudo service postgresql stop 

psql -h {VIP}-p 9999 -U pgpool postgres -c "show pool_nodes"
Password for user pgpool:
 node_id | hostname | port | status | pg_status | lb_weight |  role   | pg_role | select_cnt | load_balance_node | replication_delay | replication_state | replication_sync_state | last_status_change
---------+----------+------+--------+-----------+-----------+---------+---------+------------+-------------------+-------------------+-------------------+------------------------+---------------------
 0       | server1  | 5432 | down   | down      | 0.333333  | standby | unknown | 0          | false             | 0                 |                   |                        | 2021-10-19 07:10:01
 1       | server2  | 5432 | up     | up        | 0.333333  | primary | primary | 0          | false             | 0                 |                   |                        | 2021-10-19 07:10:01
 2       | server3  | 5432 | up     | up        | 0.333333  | standby | standby | 0          | true              | 0                 | streaming         | async                  | 2021-10-19 07:10:03
</code></pre></div></div>
<p>정상서비스 작동하며 server2가 primary가 되고 server1은 다운된걸 확인 할 수 있다.</p>

<p>Online Recovery도 된다고 되어있는데 실제 해보니 작동이 안되는거 같다 이부분은 좀더 분석이 필요 할거 같다.
그래서 추후 failback은 수동으로 작업해주면 될 것 같다.</p>

<h2 id="4-각-스크립트-파일-ubuntu에-맞게-설정되어-있다">4. 각 스크립트 파일 (ubuntu에 맞게 설정되어 있다.)</h2>

<h3 id="41-failoversh">4.1 failover.sh</h3>
<p>https://git.postgresql.org/gitweb/?p=pgpool2.git;a=blob_plain;f=src/sample/scripts/failover.sh.sample;hb=refs/heads/V4_3_STABLE</p>
<ul>
  <li>PGHOME = /usr/lib/postgresql/14 //우분투 기준 path
    <h3 id="42-follow_primarysh">4.2 follow_primary.sh</h3>
    <p>https://git.postgresql.org/gitweb/?p=pgpool2.git;a=blob_plain;f=src/sample/scripts/follow_primary.sh.sample;hb=refs/heads/V4_3_STABLE</p>
  </li>
  <li>PGHOME = /usr/lib/postgresql/14</li>
  <li>PCP_USER = pgpool
    <h3 id="43-recovery_1st_stage">4.3 recovery_1st_stage</h3>
    <p>https://git.postgresql.org/gitweb/?p=pgpool2.git;a=blob_plain;f=src/sample/scripts/recovery_1st_stage.sample;hb=refs/heads/V4_3_STABLE</p>
  </li>
  <li>PGHOME = /usr/lib/postgresql/14
    <h3 id="44-pgpool_remote_start">4.4 pgpool_remote_start</h3>
    <p>https://git.postgresql.org/gitweb/?p=pgpool2.git;a=blob_plain;f=src/sample/scripts/pgpool_remote_start.sample;hb=refs/heads/V4_3_STABLE</p>
  </li>
  <li>PGHOME = /usr/lib/postgresql/14
    <h3 id="45-escalationsh">4.5 escalation.sh</h3>
    <p>https://git.postgresql.org/gitweb/?p=pgpool2.git;a=blob_plain;f=src/sample/scripts/escalation.sh.sample;hb=refs/heads/V4_3_STABLE</p>
  </li>
  <li>PGPOOLS=(server1 server2 server3)</li>
  <li>VIP=192.168.137.150</li>
  <li>DEVICE=enp0s8</li>
</ul>]]></content><author><name>Eden</name></author><category term="postgresql" /><category term="postgresql" /><category term="replication" /><category term="stream" /><category term="pgpool" /><category term="watchdog" /><summary type="html"><![CDATA[postgresql db 이중화 2]]></summary></entry><entry><title type="html">postgresql db 이중화 1</title><link href="http://igothere.github.io/jekyll-theme-yat/postgresql/2022/03/28/fifth.html" rel="alternate" type="text/html" title="postgresql db 이중화 1" /><published>2022-03-28T00:00:00+00:00</published><updated>2022-03-28T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/postgresql/2022/03/28/fifth</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/postgresql/2022/03/28/fifth.html"><![CDATA[<h1 id="postgresql-db-이중화-1">postgresql db 이중화 1</h1>

<h2 id="-먼저-궁극적인-목적은-postgresql-이중화--pgpool2-를-사용하여-자동-failover-환경을-구축하는-것이다-이-페이지에서는-자동-failover-구성에-앞서-postgresql-replication-방법에-대해-먼저-설명한다">* 먼저 궁극적인 목적은 postgresql 이중화 + pgpool2 를 사용하여 자동 failover 환경을 구축하는 것이다. 이 페이지에서는 자동 failover 구성에 앞서 postgresql replication 방법에 대해 먼저 설명한다.</h2>

<h2 id="1-postgresql-버전-및-구축환경">1. postgresql 버전 및 구축환경</h2>
<p>보통 검색해보면 centos 기준으로 설명이 많이 나와있다. 여기서는 우분투 서버 기준으로 설명한다.</p>
<ul>
  <li>OS - ubuntu 20.04 서버 3대 (primary - standby - standby)</li>
  <li>Postgresql14 버전</li>
  <li>$PGDATA  - /var/lib/postgresql/14/main</li>
  <li>Archive mode - on</li>
  <li>Replication Slot - 사용</li>
</ul>

<h2 id="2-postgresql-14-버전-설치">2. postgresql 14 버전 설치</h2>
<ul>
  <li>https://www.postgresql.org/download/linux/ubuntu/</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" &gt; /etc/apt/sources.list.d/pgdg.list'

wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -

sudo apt-get update

sudo apt-get -y install postgresql

</code></pre></div></div>

<h2 id="3-replication-복제방식은-postgresql에서-제공하는-streaming">3. Replication 복제방식은 postgresql에서 제공하는 Streaming</h2>
<p>설명은 인터넷에 굉장히 잘 되어 있기 떄문에 설정 방법에 대해서만 기술</p>
<h3 id="31-archive-디렉토리-생성-primarystandby">3.1 archive 디렉토리 생성 (primary,standby)</h3>
<ul>
  <li>postgresql DB를 설치 했다면 자동으로 postgres 계정이 생성되어 있다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>su - postgres //이렇게 하면 postgres계정은 패스워드 없이 생성되기 때문에 바로 변경 할 수 없다. 추후 pgpool 설정시에도 postgres 의 비밀번호가 필요 하기 때문에 미리 생성해두자

[all servers]# sudo su

[all servers]# passwd postgres 

</code></pre></div></div>
<ul>
  <li>postgres 비밀번호 생성후</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[all servers]# su - postgres

[all servers]# mkdir /var/lib/postgresql/archivedir

</code></pre></div></div>
<h3 id="32-postgresqlconf-설정-primary-파일-위치는-etcpostgresql14main">3.2 postgresql.conf 설정 (primary) 파일 위치는 /etc/postgresql/14/main</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listen_addresses = '*'
archive_mode = on
archive_command = 'cp "%p" "/var/lib/postgresql/archivedir/%f"'
max_wal_senders = 10
max_replication_slots = 10
wal_level = replica
hot_standby = on
wal_log_hints = on
</code></pre></div></div>

<h3 id="33-postgresql-계정생성-primary">3.3 postgresql 계정생성 (primary)</h3>
<p>추후 pgpool을 사용하여 failover 할것이기 때문에 계정은 미리 생성해두자
 postgresql 예전버전은 scram-sha-256 없고 md5 였는데 특정버전부터 추가 되었다.
 여기서는 최신 postgresql로 작업중이라 scram-sha-256 사용한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[primary]# psql -U postgres -p 5432

postgres=# SET password_encryption = 'scram-sha-256';

postgres=# CREATE ROLE pgpool WITH LOGIN;

postgres=# CREATE ROLE repl WITH REPLICATION LOGIN;

postgres=# \password pgpool

postgres=# \password repl

postgres=# \password postgres

GRANT pg_monitor TO pgpool;

</code></pre></div></div>

<p>repl - replication user <br />
pgpool - pgpool user</p>
<h3 id="34-pg_hbaconf-설정-primarystandby">3.4 pg_hba.conf 설정 (primary,standby)</h3>
<p>일단 나의 설정은 이렇게 되어 있다. 각 내용의 자세한 설명은 검색해보면 잘 설명되어 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Database administrative login by Unix domain socket
local   all             postgres                                scram-sha-256

# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     peer
# IPv4 local connections:
host    all             all             0.0.0.0/0               scram-sha-256
# IPv6 local connections:
host    all             all             ::1/128                 scram-sha-256
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                                     peer
host    replication     all             0.0.0.0/0               scram-sha-256

</code></pre></div></div>

<p>다 설정한후</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo service postgresql restart

</code></pre></div></div>
<h3 id="35-primary-서버의-데이터-복제백업-standby">3.5 primary 서버의 데이터 복제/백업 (standby)</h3>
<ul>
  <li>먼저 혹시모를 상황에 대비해 기본 data 디렉토리 백업하고 시작하자.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo service postgresql stop

su - postgres

cd /var/lib/postgresql/14

mv main main.bak

mkdir main

chown postgres:postgres main

chmod 0700 main

//복제 하는 부분
/usr/lib/postgresql/14/bin/pg_basebackup -h {primary server ip} -D /var/lib/postgresql/14/main -U repl -v -P -R -X stream -C -S server2

//pg_basebackup 옵션 확인
pg_basebackup --help
</code></pre></div></div>

<p>완료후 /var/lib/postgresql/14/main에 정상적으로 복사되어 있는지 확인</p>
<ul>
  <li>standby.signal은 빈파일로 자동 생성되어 있음</li>
  <li>postgresql.auto.conf에 primary 서버 정보가 들어가 있다.</li>
  <li>DB</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo service postgresql start

</code></pre></div></div>
<h3 id="36-정상-확인-primarystandby">3.6 정상 확인 (primary,standby)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psql -U postgres

postgres=# select pg_is_in_recovery();

//primary에서는 f standby에서는 t 라는 결과가 나오면 정상적으로 적용

</code></pre></div></div>

<p>테스트를 해보면 primary에서 테이블 생성하고 데이터를 넣고 standby에도 정상적으로 입력 되는지 확인해보자
CREATE TABLE test (
  name	VARCHAR(20),
  age	INT
);
INSERT INTO test VALUES(‘김성공’, 23);</p>

<h3 id="37-참고-사이트">3.7 참고 사이트</h3>
<p>https://www.pgpool.net/docs/latest/en/html/example-cluster.html#EXAMPLE-CLUSTER-STRUCTURE <br />
https://yjkim97.tistory.com/57</p>]]></content><author><name>Eden</name></author><category term="postgresql" /><category term="postgresql" /><category term="replication" /><category term="stream" /><summary type="html"><![CDATA[postgresql db 이중화 1]]></summary></entry><entry><title type="html">Ansible AWX사용해서 PC원격관리 해보기</title><link href="http://igothere.github.io/jekyll-theme-yat/ansible/2022/02/16/forth.html" rel="alternate" type="text/html" title="Ansible AWX사용해서 PC원격관리 해보기" /><published>2022-02-16T00:00:00+00:00</published><updated>2022-02-16T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/ansible/2022/02/16/forth</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/ansible/2022/02/16/forth.html"><![CDATA[<h1 id="awx">AWX</h1>

<p>먼저 awx가 설치되어있는 환경에서 awx를 통해 원격관리를 하기 위한 기본 설정에 대해서 설명한다.</p>

<ol>
  <li>Project 등록
프로젝트는 awx 설정 파일에서 먼저 주석해제후 내가 원하는 경로로 지정해주면 된다.
프로젝트의 용도는 미리 플레이북을 만들어 프로젝트 디렉토리에 넣은 후 사용하기 위함이다.
17.1.0 버전 기준으로 아래 화면과 같다.</li>
</ol>

<p><img src="https://boostnote.io/api/teams/i8xSRJrmd/files/2c1b912e8407249306fa11c6e80bdd9e5352ed7da6ca3e479661c913e0c1a541-awx-project.png" alt="awx-project.png" /></p>

<ol>
  <li>Credential 관리
원격pc에 원할하게 접속하기 위해 미리 인증정보 같은 것들을 입력해 놓는 곳이다.
먼저 나는 일반 pc를 관리 할거 니깐 Credential Type 에서 Machine을 선택하고
관리대상pc의 계정정보를 입력한다.
SSH Private Key는 awx가 설치되어 있는 서버의 key를 가져오면 된다.
key 생성명령어는</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen -t rsa
</code></pre></div></div>
<p>명령어를 입력하면 3개의 값을 입력하라고 나오는데 특별한 이유가 없다면 그냥 엔터로 넘어가는게 좋다.</p>
<ol>
  <li>키를 저장할 경로( 기본값 : $HOME/.ssh/id_rsa)</li>
  <li>passphrase (추가로 사용할 암호, 기본값 없음)</li>
  <li>passphrase 확인</li>
</ol>

<p>key생성이 완료되면 $HOME/.ssh 경로에 id_rsa와 id_rsa.pub이란 파일이 생성되는데 awx에서 SSH Private Key 입력은 id_rsa를 vi나 nano 편집기로 열어서 전체 복사해서 입력해주면 된다.
마지막으로 원격관리할 pc에서 sudo 권한이 필요할수도 있으니 맨 마지막 Privilege Escalation Password에 계정 비밀번호를 입력해준다.</p>
<h4 id="여기서-중요한점은-원격pc의-계정이-sudo권한이-있어야지만-awx에서-사용할-수-있다">여기서 중요한점은 원격pc의 계정이 sudo권한이 있어야지만 awx에서 사용할 수 있다.</h4>
<p>sudo 권한은 sudo usermod -aG sudo $USER로 주거나 /etc/sudoers 파일에 awx ALL=(ALL:ALL) ALL 추가해주면 된다. 화면은 아래와 같다.
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/5885eee6a5e5d53340cc57f85418b8c4de092cf6cc3eda16a482e51a1a1d7bfd-awx-credential.png" alt="awx-credential.png" /></p>

<ol>
  <li>
    <p>Inventory 관리
인벤토리는 관리할 pc들의 group및 host정보를 저장해 놓는 곳이다.
크게 설명할 부분은 없고 아래 화면같이 group탭과 Hosts탭에서 그룹명과 HostIP를 입력해 놓으면 된다.
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/5d6f50b4e74a0dcb4a1e1d1906954724ba0d17d0cecd6899d8e4f776b4ce0dd5-awx-inventory.png" alt="awx-inventory.png" />
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/c81563dfb6c7d949dd219c2dd5a00e3b6cec5a20c9edc351f0b1b9499f1e6f08-awx-inven-groups.png" alt="awx-inven-groups.png" />
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/7fb8eef3d2227a7a78eaa9c6c3d34aa8751a4c8b5ef1a895f2eadefbe42f4301-awx-inven-hosts.png" alt="awx-inven-hosts.png" /></p>
  </li>
  <li>
    <p>간단한 ad_hoc_commands 테스트</p>
  </li>
</ol>

<p>인벤토리의 Hosts탭으로 이동 후 명령을 내릴 pc를 체크 한 후 Run Command 버튼을 클릭한다.
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/73450561373616aa7dec1731d595ad79afc3c2a5fe49c829028513d53ed6358e-awx-adhook.png" alt="awx-adhook.png" />
첫번째 Module은 ping으로 넣어주고 Next 버튼을 클릭</p>

<p>두번쨰 Machine credential은 미리 등록해 놓은 credential 을 체크 한후 Launch 버튼을 클릭
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/3cf9b26fb43fcbfe2f21507a70f5ead87805aeaa90ba44dbc8d7ce495c236ada-awx-adhook-credential.png" alt="awx-adhook-credential.png" />
성공하면 아래와 같은 성공로그가 나온다.
<img src="https://boostnote.io/api/teams/i8xSRJrmd/files/001640ab5041a3b8ba3f54b5b798235b5101c56570c3e369973fff06e72ad093-awx-job.png" alt="awx-job.png" /></p>

<h3 id="이렇게-asible-awx를-사용하여-pc관리를-해보자">이렇게 Asible AWX를 사용하여 PC관리를 해보자!</h3>]]></content><author><name>Eden</name></author><category term="ansible" /><category term="ansible" /><category term="awx" /><summary type="html"><![CDATA[AWX]]></summary></entry><entry><title type="html">spring에서 Webclient 사용하여 RestApi 통신 하기</title><link href="http://igothere.github.io/jekyll-theme-yat/spring/2022/01/27/third.html" rel="alternate" type="text/html" title="spring에서 Webclient 사용하여 RestApi 통신 하기" /><published>2022-01-27T00:00:00+00:00</published><updated>2022-01-27T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/spring/2022/01/27/third</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/spring/2022/01/27/third.html"><![CDATA[<h1 id="스프링에서-webclient-간단하게-사용하기">스프링에서 Webclient 간단하게 사용하기</h1>

<h3 id="webclient의-개념에-대해서는-이미-많은-분들이-좋은-글을-작성해주셔서-실무에서-쓰는-방법-위주로-작성을-합니다">Webclient의 개념에 대해서는 이미 많은 분들이 좋은 글을 작성해주셔서 실무에서 쓰는 방법 위주로 작성을 합니다.</h3>

<p>먼저 Webclinet는 restapi를 사용하기 위한 라이브러리중 하나 이며 webflux 라이브러리가 있어야 한다. 그래서 먼저 하단의 의존성을 pom.xml에 추가해주자</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></div></div>
<p>보시다시피 webflux 라이브러리 안에 포함되어 있는 기능이다.</p>

<p>Webclient를 가장 간단하게 사용 방법은</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebClient webclient = WebClient.create().get()....
</code></pre></div></div>
<p>의 방식인데 오늘 사용할 방법은 추가로 옵션같은걸 줄수 있는 builder를 사용하여 작성하겠다. builder를 사용하여 작성하면 아래와같이 기본적으로 작성 할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebClient webclient = WebClient.builder().baseUrl("http://localhost:8080").build();
</code></pre></div></div>
<p>여기에서 옵션을 주고 싶다면 .baseUrl 앞단에 추가해주면 된다 가령 defaultHeadrs를 준다면</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WebClient wc = WebClient.builder()
      .defaultHeaders(header -&gt; header.setBasicAuth("id","password"))
      .baseUrl("http://192.168.0.212").build();
</code></pre></div></div>
<p>요런식으로 주면 된다. 위 소스를 보면 setBasicAuth란 함수를 사용했는데 restApi를 curl로 사용할때 인증정보가 필요한경우 보통 curl -k -s –user id:password 방식으로 사용을 많이하는데 setBasicAuth 함수가 spring에서 인증정보를 api서버에 전달할때 쓰는 방식중 하나이다.</p>

<p>이렇게 Webclient 기본 생성이 완료가 되었다.
지금부터는 필요한 부분을 불러오는 방법을 기술하겠다. 방법은 여러가지가 있는데 저는 Mono를 사용하여 가져왔다.
먼저 get을 사용하기 위해서는 아래와 같이 해준다.
여기서 저는 Ansible tower restApi 테스트중이라 Ansible tower restApi 기준으로 소스를 작성하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public String getInventoryList(){

      WebClient wc = WebClient.builder()
      .defaultHeaders(header -&gt; header.setBasicAuth("id","password"))
      .baseUrl("http://localhost").build();
      
      try {
        Mono&lt;String&gt; response = wc.get().uri(UriBuilder -&gt; UriBuilder
        .path("/api/v2/inventories/")
        .build())
        .exchange().flatMap(clientResponse -&gt; {
          if (clientResponse.statusCode().is5xxServerError()) {
              clientResponse.body((clientHttpResponse, context) -&gt; {
                  return clientHttpResponse.getBody();
              });
              return clientResponse.bodyToMono(String.class);
          }
          else
              return clientResponse.bodyToMono(String.class);
      });
  

        String objects = response.block();
        return objects.toString();
      } catch (Exception e) {
        //TODO: handle exception
      }
      return null;
  
    }
</code></pre></div></div>
<p>요렇게 작성해주면 현재 ansible tower에 생성되어 있는 inventory 목록을 가져 올수 있다. 그리고 상단의 소스중</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        .exchange().flatMap(clientResponse -&gt; {
          if (clientResponse.statusCode().is5xxServerError()) {
              clientResponse.body((clientHttpResponse, context) -&gt; {
                  return clientHttpResponse.getBody();
              });
              return clientResponse.bodyToMono(String.class);
          }
          else
              return clientResponse.bodyToMono(String.class);
      });
</code></pre></div></div>
<p>이부분은 혹시 모를 에러에 대비해서 return 메세지를 확인하기 위하여 사용한 것이다. 저게 필요없는 분들은 아래와같이 작성하면 더 간단하게 사용 할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
        Mono&lt;String&gt; response = wc.get().uri(UriBuilder -&gt; UriBuilder
        .path("/api/v2/inventories/")
        .build())
        .accept(MediaType.APPLICATION_JSON)
        .retrieve()
        .bodyToMono(String.class);   
</code></pre></div></div>

<p>그리고 api 경로를 보다보면 /api/v2/inventories/{id}/ 이런 형식의 경로도 있는데 이럴땐 이렇게 사용하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Mono&lt;String&gt; response = wc.get().uri(UriBuilder -&gt; UriBuilder
        .path("/api/v2/inventories/").path("{id}/")
        .build(3)

</code></pre></div></div>
<p>뒤에 경로가 더 추가된다면 .path()로 추가해주면 되고 변수를 build() 함수안에 순서대로 매핑시켜주면 된다.</p>

<p>이제는 POST 방식을 간단하게 살펴보겠다. POST에서는 입력하는 api를 사용해보도록 하겠다 입력시에는 request가 동반되기 때문에 parameter를 사용하는 방법이 추가된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public String addInventory(){

      WebClient wc = WebClient.builder()
      .defaultHeaders(header -&gt; header.setBasicAuth("id","password"))
      .baseUrl("http://localhost")
      .build();
      
      try {
        String request = "{\"name\": \"name\",\"description\": \"description\",\"source\": \"custom\"}";
        Mono&lt;String&gt; response = wc.post()
        .uri(UriBuilder -&gt; UriBuilder
        .path("/api/v2/inventories/")
        .build())
        .contentType(MediaType.APPLICATION_JSON)
        .body(BodyInserters.fromValue(request))
        .accept(MediaType.APPLICATION_JSON)
        .retrieve()
        .bodyToMono(String.class); 

        String objects = response.block();
        return objects.toString();
      } catch (Exception e) {
        //TODO: handle exception
      }
      return null;
  
    }
</code></pre></div></div>
<p>보통 json으로 많이 보내기 떄문에 위 소스처럼 json 형식으로 만든뒤에 .body(BodyInserters.fromValue(request)) 요렇게 붙혀서 사용하면 된다.</p>

<h3 id="이렇게-간단하게-webclient를-사용하여-restapi를-사용해보자">이렇게 간단하게 Webclient를 사용하여 restApi를 사용해보자!</h3>]]></content><author><name>Eden</name></author><category term="spring" /><category term="spring" /><category term="webclient" /><category term="ansible" /><category term="awx" /><category term="restapi" /><summary type="html"><![CDATA[스프링에서 Webclient 간단하게 사용하기]]></summary></entry><entry><title type="html">ubuntu에 php 개발환경 구축하기</title><link href="http://igothere.github.io/jekyll-theme-yat/dev/2022/01/18/second.html" rel="alternate" type="text/html" title="ubuntu에 php 개발환경 구축하기" /><published>2022-01-18T00:00:00+00:00</published><updated>2022-01-18T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/dev/2022/01/18/second</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/dev/2022/01/18/second.html"><![CDATA[<h1 id="php-개발환경-구축">php 개발환경 구축</h1>

<h2 id="1-php-설치">1. php 설치</h2>

<p>sudo apt install php{version}-*</p>

<p>{version}을 안넣으면 해당 저장소의 최신버전으로 설치 됨 php에서 제공하는 최신버전으로 설치하고 싶으면 php 저장소를 추가하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   add-apt-repository ppa:ondrej/php
   sudo apt-get update
   sudo apt-get install php8.0-*
</code></pre></div></div>

<h2 id="2-composer-설치">2. composer 설치</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   curl -sS https://getcomposer.org/installer | sudo php -- --install-dir=/usr/local/bin/
   sudo ln -s /usr/local/bin/composer.phar /usr/local/bin/composer
</code></pre></div></div>

<p>참고 - https://www.lesstif.com/php-and-laravel/php-composer-23757293.html</p>

<h2 id="3-phpunit-설치">3. phpunit 설치</h2>

<p>composer require –dev phpunit/phpunit {version}</p>

<p>phpunit이 설치 되려면 php-xml , php-mbstring 이 설치되어 있어야 한다.</p>

<p>php 버전별 phpunit 버전 확인은 아래 사이트에서 확인</p>

<p>https://phpunit.de/supported-versions.html</p>

<p>phpunit은 전역설치 하지말고 해당프로젝트 상위에서 설치하는게 좋다 그럼</p>

<p>vendor/bin/phpunit 으로 생성된다.</p>

<h2 id="4-phpunit-테스팅">4. phpunit 테스팅</h2>

<p>php vendor/bin/phpunit {filepath}</p>

<h2 id="5-apache2--php-연동">5. apache2 + php 연동</h2>

<p>sudo apt install apache2</p>

<p>sudo apt install libapache2-mod-php{version}</p>

<p>sudo a2enmod php{version}</p>

<p>sudo a2enmod rewrite</p>

<p>sudo vi /etc/apache2/apache2.conf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   &lt;Directory /YOUR_PATH/&gt;
           Options Indexes FollowSymLinks
           AllowOverride all
           Require all granted
   &lt;/Directory&gt;
</code></pre></div></div>

<p>sudo service apache2 restart</p>]]></content><author><name>Eden</name></author><category term="dev" /><category term="ubuntu" /><category term="php" /><summary type="html"><![CDATA[php 개발환경 구축]]></summary></entry><entry><title type="html">첫번째 포스트 입니다!!</title><link href="http://igothere.github.io/jekyll-theme-yat/jekyll/2022/01/11/first.html" rel="alternate" type="text/html" title="첫번째 포스트 입니다!!" /><published>2022-01-11T00:00:00+00:00</published><updated>2022-01-11T00:00:00+00:00</updated><id>http://igothere.github.io/jekyll-theme-yat/jekyll/2022/01/11/first</id><content type="html" xml:base="http://igothere.github.io/jekyll-theme-yat/jekyll/2022/01/11/first.html"><![CDATA[<h1 id="블로그-시작">블로그 시작!!</h1>]]></content><author><name>Eden</name></author><category term="jekyll" /><category term="jekyll" /><category term="theme" /><category term="yat" /><summary type="html"><![CDATA[블로그 시작!!]]></summary></entry></feed>